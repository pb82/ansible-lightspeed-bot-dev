// You can import your modules
import nock from 'nock'
// Requiring our app implementation
import { lightspeedAppFunction, WebhookHandler } from '../src/app'
import { Probot, ProbotOctokit } from 'probot'
// Requiring our fixtures
import payload from './fixtures/issues.opened.json'
import fs from 'fs'
import path from 'path'
import { Router } from 'express'
import { BaseClient, Issuer } from 'openid-client'
import repositoryEditedPayload from './fixtures/repository.edited.json'
import { Stream } from 'stream'
import pino from 'pino'
import { BOT_REPO_TOPIC } from '../src/utils/constants'
import { DiagnosticsService } from '../src/services/diagnostics'

const issueCreatedBody = { body: 'Thanks for opening this issue!' }
const pullRequestCreateBody = {
  body: 'This pull request was automatically generated by the Ansible Code Bot.'
}

const privateKey = fs.readFileSync(
  path.join(__dirname, 'fixtures/mock-cert.pem'),
  'utf-8'
)

describe('My Probot app', () => {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let probot: any
  let logOutput: string[] = []

  beforeEach(() => {
    logOutput = []
    process.env.DATABASE_TYPE = 'memory'
    process.env.AUTHZ_SSO_CLIENT_ID = 'dummy'
    process.env.AUTHZ_SSO_CLIENT_SECRET = 'dummy'
    process.env.AUTHZ_SSO_SERVER = 'https://sso.dummy.com'
    process.env.AUTHZ_REDIRECT_URL = 'http://localhost:3000/auth/login/callback'
    process.env.AUTHZ_API_SERVER = 'https://api.dummy.com'
    process.env.AUTHZ_SESSION_KEY = 'secretkey'
    process.env.AUTHZ_AMS_CLIENT_ID = 'dummy'
    process.env.AUTHZ_AMS_CLIENT_SECRET = 'dummy'
    process.env.GH_CONFIG_BOT_MAIL = 'dummy'
    process.env.GH_CONFIG_BOT_USER = 'dummy'

    nock.disableNetConnect()

    const streamLogsToOutput = new Stream.Writable({ objectMode: true })
    streamLogsToOutput._write = (object, _, done) => {
      logOutput.push(JSON.parse(object).msg)
      done()
    }

    probot = new Probot({
      appId: 123,
      log: pino(streamLogsToOutput),
      privateKey,
      // disable request throttling and retries for testing
      Octokit: ProbotOctokit.defaults({
        retry: { enabled: false },
        throttle: { enabled: false }
      })
    })

    // mock the oidc client
    Issuer.discover = function () {
      return Promise.resolve(new Issuer<BaseClient>({ issuer: 'https://sso.dummy.com' }))
    }

    // Load our app into probot
    probot.load(lightspeedAppFunction, {
      getRouter: function (): Router {
        return Router()
      }
    })
  })

  test('handle repository edited webhook', async () => {
    nock('https://api.github.com')
    // Test that we correctly return a test token
      .post('/app/installations/2/access_tokens')
      .reply(200, {
        token: 'test'
      })

    const handler = new WebhookHandler(probot)
    handler.handleRepositoryEdited = jest.fn()
    handler.registerWebhooks()
    await probot.receive({ name: 'repository.edited', payload: repositoryEditedPayload })
    expect(handler.handleRepositoryEdited).toBeCalled()
  })

  test('repository.edited ignores repository when topic is missing', async () => {
    nock('https://api.github.com')
    // Test that we correctly return a test token
      .post('/app/installations/2/access_tokens')
      .reply(200, {
        token: 'test'
      })

    const handler = new WebhookHandler(probot)
    handler.registerWebhooks()
    await probot.receive({ name: 'repository.edited', payload: repositoryEditedPayload })
    expect(logOutput).toContain('Repo topics, doesn\'t include a Ansible Lightspeed Bot Scan initiator topic!')
  })

  test('repository.edited handles repository when topic is present', async () => {
    nock('https://api.github.com')
    // Test that we correctly return a test token
      .post('/app/installations/2/access_tokens')
      .reply(200, {
        token: 'test'
      })

    const handler = new WebhookHandler(probot)
    handler.registerWebhooks()
    const payload = { ...repositoryEditedPayload }
    payload.repository.topics.push(BOT_REPO_TOPIC)

    jest.spyOn(DiagnosticsService.prototype, 'onRepositoryEdited').mockImplementation(async () => Promise.resolve())
    await probot.receive({ name: 'repository.edited', payload })
    expect(logOutput).toContain('Bot Manual Scan triggered by owner: lightspeed over repo: Sandbox!')
  })

  test('creates a comment when an issue is opened', async () => {
    const mock = nock('https://api.github.com')
    // Test that we correctly return a test token
      .post('/app/installations/2/access_tokens')
      .reply(200, {
        token: 'test',
        permissions: {
          issues: 'write'
        }
      })

    // Test that a comment is posted
      .post('/repos/hiimbex/testing-things/issues/1/comments', (body) => {
        expect(body).toMatchObject(issueCreatedBody)
        return true
      })
      .reply(200, {})

    // Receive a webhook event
    await probot.receive({ name: 'issues', payload })

    expect(mock.pendingMocks().length).toBe(2)
  })

  it('Should handle repository.edited webhook event', async () => {
    const mock = nock('https://api.github.com')
    // Test that we correctly return a test token
      .post('/app/installations/2/access_tokens')
      .reply(200, {
        token: 'test'
      })
    // Test that a pull request is created
      .post('/repos/hiimbex/testing-things/pull/1', (body) => {
        expect(body).toMatchObject(pullRequestCreateBody)
        return true
      })
      .reply(200, {})
    await probot.receive({ name: 'repository.edited', payload: repositoryEditedPayload })
    expect(mock.pendingMocks().length).toBe(2)
  })

  afterEach(() => {
    nock.cleanAll()
    nock.enableNetConnect()
    jest.restoreAllMocks()
  })
})
